#!/usr/bin/env python3


"""
cronic.py

cronic sets the cron job for certbot for a specific time,
Five days before the cert expires.

cronic handles cert renewal via cron.

"""

import datetime
import os
import random
import subprocess
import sys
import time


CERTBOT = "certbot"
CRONIC = os.path.realpath(__file__)
CRONTAB = "crontab"
LIST_CRON = [CRONTAB, "-l"]
INSTALL_CRON = [CRONTAB, "-"]
FOUR_HOURS = 14400
ONE_DAY = FOUR_HOURS * 6
DAYS_EARLY = 5
SECONDS_EARLY = DAYS_EARLY * ONE_DAY
DAY_SECONDS = 86400
OPENSSL_CMD=['openssl','x509','-enddate','-noout','-in']
CERT_TIME_FMT="%b %d %H:%M:%S %Y %Z"


def _renew_cert(cert_pem):
    try:
        certbot = (
            subprocess.run(["which", CERTBOT], capture_output=True)
            .stdout.decode()
            .replace("\n", "")
        )
        subprocess.run([certbot, "renew"])
    except:
        appt = time.gmtime(time.time() + FOUR_HOURS)
        print("Renewal failed, trying again @ ", appt)
        _install_cron(appt, cert_pem)


def _mk_cron_appt(appt, cert_pem):
    """
    _mk_cron_appt create the crontab line.
    """
    wday = "*"
    stamp = f" #  Renewal on {time.strftime('%a, %d %b %Y %H:%M:%S', appt)}"
    appt_job = f"\n{appt.tm_min}\t{appt.tm_hour}\t{appt.tm_mday}\t{appt.tm_mon}\t{wday}\t{CRONIC} {cert_pem} {stamp}\n"
    return appt_job.encode()


def _blank_line(job_line):
    """
    _blank_line is the line not blank?
    """
    return len(job_line) != 0


def _cronic_line(job_line):
    """
    _cronic_line is this not the last
    crontab entry by cronic?
    """
    return CRONIC.encode() not in job_line


def _vrfy_cronjob(job_line):
    """
    _vrfy_cronjob verify the line is not
    blank and not the last cronic crontab entry
    """
    vrfy=-1
    vrfy+=_blank_line(job_line)
    vrfy+=_cronic_line(job_line)
    return vrfy


def _clean_cron():
    """
    _clean_cron remove blank lines and
    the previous cronic crontab entry
    from the crontab.
    """
    cron_list = subprocess.run(LIST_CRON, capture_output=True)
    cron_jobs = [
        line.replace(b"\n", b"")
        for line in cron_list.stdout.split(b"\n")
        if _vrfy_cronjob(line)
    ]
    return b"\n".join(cron_jobs)


def _install_cron(appt, cert_pem):
    """
    _install_cron install the new crontab
    """
    job = subprocess.Popen(INSTALL_CRON, stdin=subprocess.PIPE)
    added_job = _mk_cron_appt(appt, cert_pem)
    new_cron = _clean_cron() + added_job
    job.communicate(new_cron)
    print("crontab\n")
    subprocess.call(LIST_CRON)


def _cert_not_after(cert_pem):
    """
    _cert_not_after call openssl to read cert.notAfter
    and covert to timestamp
    """
    cmd = OPENSSL_CMD+[cert_pem]
    not_after = (
            subprocess.run(cmd, capture_output=True)
            .stdout.decode()
            .replace("notAfter=", "").replace("\n","")
        )
    return datetime.datetime.strptime(not_after,CERT_TIME_FMT).timestamp()


def _random_seconds():
    return random.randint(1, DAY_SECONDS)


def _get_cert_pem():
    cert_pem = None
    if len(sys.argv) > 1:
        cert_pem = sys.argv[1]
        return  cert_pem
    print("I need a file path for the cert to renew")
    sys.exit()


def cronic():
    """
    cronic automates cronjob creation for cert renewal with certbot.
    """
    cert_pem = _get_cert_pem()
    appt = time.gmtime(time.time())
    timestamp = _cert_not_after(cert_pem)
    print(f"\n\nCertificate expires {time.ctime(timestamp)}\n\n")
    appt = time.gmtime(timestamp - SECONDS_EARLY)
    days_left = (timestamp - time.time()) / ONE_DAY
    if days_left > DAYS_EARLY:
        appt = time.gmtime(timestamp - SECONDS_EARLY + _random_seconds())
        print("Cert is not yet read for renewal, setting new cron job.\n")
        _install_cron(appt, cert_pem)
    else:
        _renew_cert(cert_pem)
        print("renewed")


if __name__ == "__main__":
    cronic()
